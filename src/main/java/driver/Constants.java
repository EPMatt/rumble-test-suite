package driver;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;

public class Constants {
    public static final Path WORKING_DIRECTORY_PATH = Paths.get("").toAbsolutePath();

    public static final boolean USE_CONVERTED_TEST_SUITE = false; // use test suite generated by converter
    public static final String OUTPUT_TEST_SUITE_DIRECTORY = "Output_Test_Suite"; // path to test suite generated by

    public static final Map<String, String> atomicTypeConversions = Map.ofEntries(
        Map.entry("xs:atomic", "atomic"),
        Map.entry("xs:anyURI", "anyURI"),
        Map.entry("xs:base64Binary", "base64Binary"),
        Map.entry("xs:boolean", "boolean"),
        Map.entry("xs:date", "date"),
        Map.entry("xs:dateTime", "dateTime"),

        Map.entry("xs:dayTimeDuration", "dayTimeDuration"),
        Map.entry("xs:decimal", "decimal"),
        Map.entry("xs:double", "double"),
        Map.entry("xs:duration", "duration"),
        Map.entry("xs:hexBinary", "hexBinary"),

        Map.entry("xs:integer", "integer"), // If we put replace for xs:int before xs:integer. In case that we have
                                            // xs:integer we would get integereger
        Map.entry("xs:int", "integer"), // int is 32bits, integer is infinite. It is okay to do this conversion now
        Map.entry("xs:string", "string"),
        Map.entry("xs:time", "time"),
        Map.entry("xs:yearMonthDuration", "yearMonthDuration")
    );

    public static final Map<String, String> nonAtomicTypeConversions = Map.ofEntries(
        // Also array(+), array(?), array()*, array()+, array()? do not exist
        Map.entry("array(*)", "array*"),

        // Will cover all the subclasses - item()+, item()* and item()+. item(anything here) does not exist
        Map.entry("item()", "item"),

        // These are not types but instantiations of boolean handled differently
        Map.entry("true()", "true"),
        Map.entry("false()", "false"),

        Map.entry("map(", "object("),
        Map.entry("map{", "{"),
        Map.entry("map {", " {")
    );

    public static final String[] unsupportedTypes = new String[] {
        "xs:byte",
        "xs:dateTimeStamp",
        "xs:float",
        "xs:gDay",
        "xs:gMonth",
        "xs:gYear",
        "xs:gYearMonth",
        "xs:long",
        "xs:negativeInteger",
        "xs:nonPositiveInteger",
        "xs:nonNegativeInteger",
        "xs:positiveInteger",
        "xs:short",
        "xs:unsignedByte",
        "xs:unsignedInt",
        "xs:unsignedLong",
        "xs:unsignedShort",
        "xs:untypedAtomic",
        "xs:dateTimeStamp",
        "xs:anyAtomicType",
        "xs:error",
        "xs:normalizedString",
        "xs:numeric",
        "xs:token",
        "xs:NMTOKEN",
        "xs:NCName",
        "xs:Name",
        "xs:language",
        "xs:ENTITY",
        "xs:ID",
        "xs:IDREF",
        "xs:anyType",
        "xs:anySimpleType",
        "xs:untyped",
        "xs:doesNotExist",
        "xs:NOTEXIST",
        "xs:doesNotExistExampleCom",
        "xs:name",
        "xs:untypedAny",
        "xs:undefinedType",
        "xs:unknownType",
        "xs:qname",
        "xs:NOTATION",
        "node()",
        "empty-sequence()"
    };

    public static final String[] supportedErrorCodes = new String[] {
        "FOAR0001",
        "FOCA0002",
        "FODC0002",
        "FOFD1340",
        "FOFD1350",
        "JNDY0003",
        "JNTY0004",
        "JNTY0024",
        "JNTY0018",
        "RBDY0005",
        "RBML0001",
        "RBML0002",
        "RBML0003",
        "RBML0004",
        "RBML0005",
        "RBST0001",
        "RBST0002",
        "RBST0003",
        "RBST0004",
        "SENR0001",
        "XPDY0002",
        "XPDY0050",
        "XPDY0130",
        "XPST0003",
        "XPST0008",
        "XPST0017",
        "XPST0080",
        "XPST0081",
        "XPTY0004",
        "XQDY0054",
        "XQST0016",
        "XQST0031",
        "XQST0033",
        "XQST0034",
        "XQST0038",
        "XQST0039",
        "XQST0047",
        "XQST0048",
        "XQST0049",
        "XQST0052",
        "XQST0059",
        "XQST0069",
        "XQST0088",
        "XQST0089",
        "XQST0094" };
}
